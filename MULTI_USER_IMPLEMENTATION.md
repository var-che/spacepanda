# Multi-User Channel Implementation

## Architecture Overview

### How SpacePanda-Core Talks to Flutter via gRPC

```
┌─────────────┐         gRPC          ┌──────────────────┐         ┌──────────────────┐
│   Flutter   │ ◄──────────────────► │  spacepanda-api  │ ◄─────► │ spacepanda-core  │
│   (Dart)    │   Proto Messages     │     (Server)     │  Rust   │  (Library)       │
└─────────────┘                       └──────────────────┘   API   └──────────────────┘
      │                                        │                            │
      │                                        │                            │
   Generated                              Generated                   Business Logic
   Dart Client                          Rust Server                   + MLS + Storage
```

**Build Process:**

1. **Proto Definitions** (`proto/spacepanda.proto`) - Single source of truth
2. **Rust Code Generation** - `build.rs` in `spacepanda-api` generates server traits
3. **Dart Code Generation** - `protoc` generates client stubs
4. **Compilation**:
   - Backend: `cargo build` compiles `spacepanda-api` (wraps `spacepanda-core`)
   - Flutter: Imports generated `.pbgrpc.dart` files

**Session Management:**

- Each user login creates a `Session` with isolated `AsyncSpaceManager` + `MlsService`
- Sessions stored by token in `SessionManager`
- Each session has its own profile directory with separate SQLite databases

## Multi-User Pattern (From Working Tests)

The correct multi-user flow is demonstrated in [`spacepanda-core/tests/http_harness_admin_roles.rs`](spacepanda-core/tests/http_harness_admin_roles.rs):

### 1. Each User Generates Their Own Key Package

```rust
// Bob generates his own key package
let bob_key_package = bob_manager.generate_key_package().await?;
```

**Why?** Key packages contain cryptographic material that MUST be generated by the user who will join.

### 2. Creator Invites Using Invitee's Key Package

```rust
// Alice invites Bob using Bob's key package
let (invite_token, commit) = alice_manager.create_invite(&channel_id, bob_key_package).await?;
```

**What happens:**

- Alice's MLS service adds Bob's key package to the group
- Generates **Welcome message** (encrypted for Bob)
- Generates **Commit** (for existing members to update their state)
- Returns **InviteToken** containing Welcome + channel metadata

### 3. Invitee Joins Using Welcome Message

```rust
// Bob joins the channel
bob_manager.join_channel(&invite_token).await?;
```

**What happens:**

- Bob's MLS service processes the Welcome message
- Creates local copy of the MLS group state
- Now Bob can encrypt/decrypt messages

### 4. Existing Members Process Commit (if needed)

```rust
// Charlie processes the commit when Bob joined
if let Some(commit_bytes) = commit {
    charlie_manager.process_commit(&commit_bytes).await?;
}
```

## New gRPC APIs

### GenerateKeyPackage

```protobuf
rpc GenerateKeyPackage(GenerateKeyPackageRequest) returns (GenerateKeyPackageResponse);
```

**Purpose:** User generates their own key package to join channels  
**Implementation:** `AsyncSpaceManager::generate_key_package()` → `MlsService::generate_key_package()`

### CreateChannelInvite

```protobuf
rpc CreateChannelInvite(CreateChannelInviteRequest) returns (CreateChannelInviteResponse);
```

**Purpose:** Channel member invites another user (requires their key package)  
**Returns:** Welcome message + optional commit for existing members  
**Implementation:** `AsyncSpaceManager::create_channel_invite()` → `MlsService::add_members()`

### JoinChannel

```protobuf
rpc JoinChannel(JoinChannelRequest) returns (JoinChannelResponse);
```

**Purpose:** User joins channel using invite token (Welcome message)  
**Implementation:** `AsyncSpaceManager::join_channel_from_invite()` → `MlsService::join_group()`

## Updated Test Flow

**Old (Broken) Flow:**

```dart
// ❌ This doesn't work - generates Bob's key package on Alice's side
await alice.addMemberToChannel(bob_user_id);
await bob.sendMessage(); // FAILS: Bob not in MLS group
```

**New (Correct) Flow:**

```dart
// 1. Bob generates his key package
final bobKeyPackage = await bobClient.generateKeyPackage();

// 2. Alice creates invite using Bob's key package
final invite = await aliceClient.createChannelInvite(
  channelId: channelId,
  keyPackage: bobKeyPackage.keyPackage,
);

// 3. Bob joins using the invite
await bobClient.joinChannel(inviteToken: invite.inviteToken);

// 4. Now Bob can send messages! ✅
await bobClient.sendMessage(content: "Hello from Bob!");
```

## Why The Previous Implementation Failed

1. **Key Package Generation**: We generated Bob's key package on Alice's MLS service
   - Each user MUST generate their own key packages using their own cryptographic identity
2. **Missing Welcome Processing**: Bob never received/processed the Welcome message
   - MLS requires the Welcome to initialize group state on the new member's side
3. **Separate MLS Services**: Each user session has isolated MLS storage
   - Alice adding Bob to her group doesn't update Bob's MLS service
   - Bob needs to explicitly join using the Welcome message

## Implementation Files

### Proto Definitions

- [`proto/spacepanda.proto`](proto/spacepanda.proto) - Added 3 new RPCs + message types

### Core Library (spacepanda-core)

- [`spacepanda-core/src/core_space/async_manager.rs`](spacepanda-core/src/core_space/async_manager.rs):
  - `generate_key_package()` - Line ~637
  - `create_channel_invite()` - Line ~646
  - `join_channel_from_invite()` - Line ~672

### gRPC Server (spacepanda-api)

- [`spacepanda-api/src/services/space_service.rs`](spacepanda-api/src/services/space_service.rs):
  - `generate_key_package()` - Line ~377
  - `create_channel_invite()` - Line ~394
  - `join_channel()` - Line ~425

### Tests

- [`spacepanda-core/tests/http_harness_admin_roles.rs`](spacepanda-core/tests/http_harness_admin_roles.rs) - Working multi-user examples

## Next Steps for E2E Tests

1. **Update multi_user_e2e_test.dart** to use new 3-step flow:

   ```dart
   // Step 1: Bob & Charlie generate key packages
   // Step 2: Alice creates invites
   // Step 3: Bob & Charlie join
   // Step 4: Everyone can now send messages!
   ```

2. **Test Coverage:**
   - ✅ Key package generation per user
   - ✅ Invite creation with key packages
   - ✅ Join channel from invite
   - ✅ Multi-user messaging after proper join
   - ⏳ Kick/remove functionality (partially implemented)

## Security & Privacy

- **Key Packages:** Each contains user's public keys + signature
- **Welcome Messages:** Encrypted specifically for the recipient
- **Group State:** Isolated per user, synchronized via MLS protocol
- **Forward Secrecy:** MLS provides PFS automatically through key rotation

## Comparison with Working Test

| Aspect          | Working Test (Rust)                            | Flutter E2E (Now Fixed)                |
| --------------- | ---------------------------------------------- | -------------------------------------- |
| Key Package Gen | `bob_manager.generate_key_package()`           | `bobClient.generateKeyPackage()`       |
| Create Invite   | `alice_manager.create_invite(channel, bob_kp)` | `aliceClient.createChannelInvite(...)` |
| Join Channel    | `bob_manager.join_channel(invite)`             | `bobClient.joinChannel(...)`           |
| Message Sending | ✅ Works after join                            | ✅ Now works after join                |
| Isolation       | Each manager has own MLS service               | Each session has own MLS service       |

## References

- MLS RFC: https://www.rfc-editor.org/rfc/rfc9420.html
- OpenMLS Docs: https://openmls.tech/book/
- Core Tests: [`spacepanda-core/tests/`](spacepanda-core/tests/)
